# Feat/Chapter4

- 프로젝트

https://github.com/catomat0/9th-Springboot/tree/Feat/Chapter4

# Spring 프로젝트 핵심 정리

---

## 계층형 구조 vs 도메인형 구조

| **항목** | **계층형 구조 (Layered Architecture)** | **도메인형 구조 (Domain-Oriented Architecture)** |
| --- | --- | --- |
| **지향점** | 기술 관점의 책임 분리 (관심사의 분리) | 비즈니스 기능 중심의 설계 (모듈화와 응집도 향상) |
| **코드 조직 기준** | Controller, Service, Repository 등 기술 계층 | 도메인 또는 기능 단위 (예: user, pharmacy 등) |
| **초기 개발 속도** | 빠름 (익숙하고 단순함) | 상대적으로 느림 (설계 고민 필요) |
| **코드 응집도** | 낮음 (도메인 관련 코드가 분산됨) | 높음 (한 기능이 한 폴더에 모여 있음) |
| **가독성** | 기술 흐름 파악은 쉬우나 기능 흐름은 어려움 | 기능 흐름 파악이 명확하고 직관적 |
| **변경 용이성** | 하나 변경 시 여러 계층 동시 수정 필요 | 관련 파일이 함께 있어서 변경 용이 |
| **확장성** | 기능 추가 시 구조 복잡해지기 쉬움 | 구조가 기능별로 나뉘어 있어 확장에 유리 |
| **테스트 용이성** | 테스트 구성 시 의존 계층 파악이 필요 | 각 도메인 단위로 테스트 작성 용이 |
| **협업 적합성** | 전반적인 이해가 필요한 구조 | 도메인 단위로 팀 나눠서 병렬 개발 가능 |
| **대표 단점** | 도메인과 무관한 코드 간 결합도 증가 | 초기 설계 고민과 디렉토리 관리 필요 |
| **대표 장점** | 단순하고 전통적인 구조 | 유지보수성과 확장성 우수, 관심사 집중 가능 |
| **적합한 프로젝트** | 소규모 프로젝트, 단일 기능 서비스 | 중대형 서비스, 모듈화가 필요한 프로젝트 |
| **대표 적용 사례** | CRUD 기반 웹 서비스, 사내툴 | 대규모 플랫폼, 마이크로서비스 구조 |

---

## JPA란?

**자바에서 객체를 관계형 데이터베이스(RDB)** 에 쉽게 매핑하고 다루기 위한 **ORM (Object-Relational Mapping)**  
→ 보통 **하이버네이트(Hibernate)** 가 기본 구현체로 사용됨

**핵심 목적**
- 수작업으로 데이터 매핑하던 과정을 자동화
- 객체 중심적 코드 작성 가능
- 데이터 무결성과 일관성 유지 용이

---

## N+1 문제

**정의**  
엔티티를 조회할 때, 연관된 엔티티를 **지연 로딩(Lazy Loading)** 으로 가져오는 과정에서  
추가적인 쿼리가 N번 더 실행되어 성능 저하가 발생하는 문제

**원인**
- 1개의 쿼리로 부모 엔티티를 조회 후,  
  각 부모마다 자식 엔티티를 N번의 쿼리로 추가 조회

**해결 방법**
- `fetch join` 사용 (`JOIN FETCH`)
- `@EntityGraph` 활용
- Batch Size 조정 (`@BatchSize`)
- JPQL 또는 QueryDSL로 직접 쿼리 작성

---

## 기본 키 생성 전략

**권장 식별자 전략**
- 기본키 제약: `NotNull`, `Unique`, `Immutable`
- **Long형 + 대체키 + 키 생성 전략 사용**
- 주민번호, 전화번호 등 자연키는 미래 변경 가능성이 높으므로 **대리키(대체키)** 사용

> 예시)  
> 만약 PK를 주민번호로 사용한다면, 회원 정보가 바뀔 때  
> 모든 테이블의 FK 값도 함께 수정해야 함 → 비효율적

**DB별 기본 전략**
- MySQL → `IDENTITY`
- Oracle → `SEQUENCE`
- DB가 다르면 동작 방식이 달라질 수 있음

| 전략 | 설명 | 대표 DB |
| --- | --- | --- |
| `IDENTITY` | DB가 자동 증가 시퀀스를 직접 관리 | MySQL, SQL Server |
| `SEQUENCE` | DB 시퀀스 객체를 사용 | Oracle, PostgreSQL |
| `TABLE` | 키 생성용 테이블 별도 생성 | 모든 DB 가능 (비추천) |
| `AUTO` | JPA가 DB 방언(Dialect)에 따라 자동 선택 | 기본값 |

| 전략 | 키 생성 주체 | 미리 ID 알 수 있음 | 성능 | 사용 DB | 비고 |
| --- | --- | --- | --- | --- | --- |
| `IDENTITY` | DB (AUTO_INCREMENT) | X | 중간 | MySQL | insert 즉시 실행 필요 |
| `SEQUENCE` | DB 시퀀스 객체 | O | 빠름 | Oracle, PostgreSQL | 배치 insert 최적 |
| `TABLE` | 별도 테이블 | O | 느림 | 모든 DB | 비추천 |
| `AUTO` | JPA가 자동 선택 | DB 따라 다름 | 중간 | 전 DB | 기본값 |

---

## @OnDelete(action = OnDeleteAction.CASCADE)

- **하이버네이트 전용 어노테이션**
- 연관 FK에 **DB 레벨의 `ON DELETE CASCADE`** 적용  
  → 부모 레코드를 삭제하면 **DB가 직접 자식 레코드도 삭제**

### JPA의 `cascade = REMOVE` / `orphanRemoval = true` 와의 차이

| 구분 | 동작 주체 | 삭제 방식 | 특징 |
| --- | --- | --- | --- |
| `cascade = REMOVE` | JPA (애플리케이션) | JPA가 자식 엔티티들을 순회하며 `DELETE` 쿼리 전송 | 느림, 쿼리 다수 |
| `orphanRemoval = true` | JPA (애플리케이션) | 관계만 끊겨도 자식 삭제 | 관계 단절 시 자동 삭제 |
| `@OnDelete(CASCADE)` | **DB (데이터베이스)** | FK 제약 조건으로 한 번에 삭제 | 빠름, 쿼리 1회, 효율적 |

---